{
  "_args": [
    [
      {
        "raw": "tapable@^2.2.0",
        "scope": null,
        "escapedName": "tapable",
        "name": "tapable",
        "rawSpec": "^2.2.0",
        "spec": ">=2.2.0 <3.0.0",
        "type": "range"
      },
      "c:\\Angular\\TaskManager\\node_modules\\enhanced-resolve"
    ]
  ],
  "_from": "tapable@^2.2.0",
  "_hasShrinkwrap": false,
  "_id": "tapable@2.2.0",
  "_location": "/tapable",
  "_nodeVersion": "14.15.1",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/tapable_2.2.0_1607090220264_0.5042022096574259"
  },
  "_npmUser": {
    "name": "sokra",
    "email": "tobias.koppers@googlemail.com"
  },
  "_npmVersion": "6.14.8",
  "_phantomChildren": {},
  "_requested": {
    "raw": "tapable@^2.2.0",
    "scope": null,
    "escapedName": "tapable",
    "name": "tapable",
    "rawSpec": "^2.2.0",
    "spec": ">=2.2.0 <3.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/enhanced-resolve",
    "/webpack",
    "/webpack/enhanced-resolve"
  ],
  "_resolved": "https://registry.npmjs.org/tapable/-/tapable-2.2.0.tgz",
  "_shasum": "5c373d281d9c672848213d0e037d1c4165ab426b",
  "_shrinkwrap": null,
  "_spec": "tapable@^2.2.0",
  "_where": "c:\\Angular\\TaskManager\\node_modules\\enhanced-resolve",
  "author": {
    "name": "Tobias Koppers @sokra"
  },
  "browser": {
    "util": "./lib/util-browser.js"
  },
  "bugs": {
    "url": "https://github.com/webpack/tapable/issues"
  },
  "dependencies": {},
  "description": "Just a little module for plugins.",
  "devDependencies": {
    "@babel/core": "^7.4.4",
    "@babel/preset-env": "^7.4.4",
    "babel-jest": "^24.8.0",
    "codecov": "^3.5.0",
    "jest": "^24.8.0",
    "prettier": "^1.17.1"
  },
  "directories": {},
  "dist": {
    "integrity": "sha512-FBk4IesMV1rBxX2tfiK8RAmogtWn53puLOQlvO8XuwlgxcYbP4mVPS9Ph4aeamSyyVjOl24aYWAuc8U5kCVwMw==",
    "shasum": "5c373d281d9c672848213d0e037d1c4165ab426b",
    "tarball": "https://registry.npmjs.org/tapable/-/tapable-2.2.0.tgz",
    "fileCount": 20,
    "unpackedSize": 46875,
    "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfykAsCRA9TVsSAnZWagAA9JcQAJD0QGtio8EhwPBQs9Fh\nv0K4ZkoN1YCzW2iME0bsHSQE1PvJprer5LiaXlmIsMuG3/2ptH65+/V+gQZP\nrCe769utxLrT0x6Ra9FTdOmfRTT3FUgKOiMAk7tMOtsu/ICwOz97w7sQ2H6Y\nYFhX754n1Tx9hvcbLVaLVcpJaAqgG4FSAaya5OX9P8Z843eHTyNi4a2piFd6\nmRcwCl2Zdz2i6JOpyyNsvFExerqu1vfmdh742XYRYoEpuT5L2Mg2XX860ZBP\nfp05TjvLpJ6OQN8QRmvr4eVsJjkj9yiDrMYkQyphvDPSDtFJ9T1LcMsatjah\nW6mUv1X/ImY39WiFT7ECx2o0KCyh5gDeD8wV6rPyMjzEImT+Z+tQL1guzmAJ\nu7M1g40BLbR3mM9Z2NF5Gt8hKdELJgv20UfQdlBtf2BoU5fDbSTPzyqeQBmu\ncV0b8y+YihEoDvHQwQ2YUOilahvNSP4J87HXpty0rxBZSPx73+p1LCm3xIdJ\n/5m8MD3/AcNh3ogXzTevYzpqNZXGi5UFs/eowQssCAi5ODpZeHUt6VR6GJkt\ngyj54KMq/rba4dGomjYoaHmQNS8nCfOB9Gc2R4O2NDPZS9t/QIn4TpJjeFy5\nGUUHW9Cip51YlJbJ9xlmbYmM1hbFE9vfm0FxDpQvbREwboNuL0EN49t6KNIe\nWx0y\r\n=sMT2\r\n-----END PGP SIGNATURE-----\r\n"
  },
  "engines": {
    "node": ">=6"
  },
  "files": [
    "lib",
    "!lib/__tests__",
    "tapable.d.ts"
  ],
  "gitHead": "413fa785018406464963c29d172e06d2df42f22e",
  "homepage": "https://github.com/webpack/tapable",
  "jest": {
    "transform": {
      "__tests__[\\\\/].+\\.js$": "babel-jest"
    }
  },
  "license": "MIT",
  "main": "lib/index.js",
  "maintainers": [
    {
      "name": "sokra",
      "email": "tobias.koppers@googlemail.com"
    }
  ],
  "name": "tapable",
  "optionalDependencies": {},
  "readme": "# Tapable\n\nThe tapable package expose many Hook classes, which can be used to create hooks for plugins.\n\n``` javascript\nconst {\n\tSyncHook,\n\tSyncBailHook,\n\tSyncWaterfallHook,\n\tSyncLoopHook,\n\tAsyncParallelHook,\n\tAsyncParallelBailHook,\n\tAsyncSeriesHook,\n\tAsyncSeriesBailHook,\n\tAsyncSeriesWaterfallHook\n } = require(\"tapable\");\n```\n\n## Installation\n\n``` shell\nnpm install --save tapable\n```\n\n## Usage\n\nAll Hook constructors take one optional argument, which is a list of argument names as strings.\n\n``` js\nconst hook = new SyncHook([\"arg1\", \"arg2\", \"arg3\"]);\n```\n\nThe best practice is to expose all hooks of a class in a `hooks` property:\n\n``` js\nclass Car {\n\tconstructor() {\n\t\tthis.hooks = {\n\t\t\taccelerate: new SyncHook([\"newSpeed\"]),\n\t\t\tbrake: new SyncHook(),\n\t\t\tcalculateRoutes: new AsyncParallelHook([\"source\", \"target\", \"routesList\"])\n\t\t};\n\t}\n\n\t/* ... */\n}\n```\n\nOther people can now use these hooks:\n\n``` js\nconst myCar = new Car();\n\n// Use the tap method to add a consument\nmyCar.hooks.brake.tap(\"WarningLampPlugin\", () => warningLamp.on());\n```\n\nIt's required to pass a name to identify the plugin/reason.\n\nYou may receive arguments:\n\n``` js\nmyCar.hooks.accelerate.tap(\"LoggerPlugin\", newSpeed => console.log(`Accelerating to ${newSpeed}`));\n```\n\nFor sync hooks, `tap` is the only valid method to add a plugin. Async hooks also support async plugins:\n\n``` js\nmyCar.hooks.calculateRoutes.tapPromise(\"GoogleMapsPlugin\", (source, target, routesList) => {\n\t// return a promise\n\treturn google.maps.findRoute(source, target).then(route => {\n\t\troutesList.add(route);\n\t});\n});\nmyCar.hooks.calculateRoutes.tapAsync(\"BingMapsPlugin\", (source, target, routesList, callback) => {\n\tbing.findRoute(source, target, (err, route) => {\n\t\tif(err) return callback(err);\n\t\troutesList.add(route);\n\t\t// call the callback\n\t\tcallback();\n\t});\n});\n\n// You can still use sync plugins\nmyCar.hooks.calculateRoutes.tap(\"CachedRoutesPlugin\", (source, target, routesList) => {\n\tconst cachedRoute = cache.get(source, target);\n\tif(cachedRoute)\n\t\troutesList.add(cachedRoute);\n})\n```\nThe class declaring these hooks need to call them:\n\n``` js\nclass Car {\n\t/**\n\t  * You won't get returned value from SyncHook or AsyncParallelHook,\n\t  * to do that, use SyncWaterfallHook and AsyncSeriesWaterfallHook respectively\n\t **/\n\n\tsetSpeed(newSpeed) {\n\t\t// following call returns undefined even when you returned values\n\t\tthis.hooks.accelerate.call(newSpeed);\n\t}\n\n\tuseNavigationSystemPromise(source, target) {\n\t\tconst routesList = new List();\n\t\treturn this.hooks.calculateRoutes.promise(source, target, routesList).then((res) => {\n\t\t\t// res is undefined for AsyncParallelHook\n\t\t\treturn routesList.getRoutes();\n\t\t});\n\t}\n\n\tuseNavigationSystemAsync(source, target, callback) {\n\t\tconst routesList = new List();\n\t\tthis.hooks.calculateRoutes.callAsync(source, target, routesList, err => {\n\t\t\tif(err) return callback(err);\n\t\t\tcallback(null, routesList.getRoutes());\n\t\t});\n\t}\n}\n```\n\nThe Hook will compile a method with the most efficient way of running your plugins. It generates code depending on:\n* The number of registered plugins (none, one, many)\n* The kind of registered plugins (sync, async, promise)\n* The used call method (sync, async, promise)\n* The number of arguments\n* Whether interception is used\n\nThis ensures fastest possible execution.\n\n## Hook types\n\nEach hook can be tapped with one or several functions. How they are executed depends on the hook type:\n\n* Basic hook (without “Waterfall”, “Bail” or “Loop” in its name). This hook simply calls every function it tapped in a row.\n\n* __Waterfall__. A waterfall hook also calls each tapped function in a row. Unlike the basic hook, it passes a return value from each function to the next function.\n\n* __Bail__. A bail hook allows exiting early. When any of the tapped function returns anything, the bail hook will stop executing the remaining ones.\n\n* __Loop__. When a plugin in a loop hook returns a non-undefined value the hook will restart from the first plugin. It will loop until all plugins return undefined.\n\nAdditionally, hooks can be synchronous or asynchronous. To reflect this, there’re “Sync”, “AsyncSeries”, and “AsyncParallel” hook classes:\n\n* __Sync__. A sync hook can only be tapped with synchronous functions (using `myHook.tap()`).\n\n* __AsyncSeries__. An async-series hook can be tapped with synchronous, callback-based and promise-based functions (using `myHook.tap()`, `myHook.tapAsync()` and `myHook.tapPromise()`). They call each async method in a row.\n\n* __AsyncParallel__. An async-parallel hook can also be tapped with synchronous, callback-based and promise-based functions (using `myHook.tap()`, `myHook.tapAsync()` and `myHook.tapPromise()`). However, they run each async method in parallel.\n\nThe hook type is reflected in its class name. E.g., `AsyncSeriesWaterfallHook` allows asynchronous functions and runs them in series, passing each function’s return value into the next function.\n\n\n## Interception\n\nAll Hooks offer an additional interception API:\n\n``` js\nmyCar.hooks.calculateRoutes.intercept({\n\tcall: (source, target, routesList) => {\n\t\tconsole.log(\"Starting to calculate routes\");\n\t},\n\tregister: (tapInfo) => {\n\t\t// tapInfo = { type: \"promise\", name: \"GoogleMapsPlugin\", fn: ... }\n\t\tconsole.log(`${tapInfo.name} is doing its job`);\n\t\treturn tapInfo; // may return a new tapInfo object\n\t}\n})\n```\n\n**call**: `(...args) => void` Adding `call` to your interceptor will trigger when hooks are triggered. You have access to the hooks arguments.\n\n**tap**: `(tap: Tap) => void` Adding `tap` to your interceptor will trigger when a plugin taps into a hook. Provided is the `Tap` object. `Tap` object can't be changed.\n\n**loop**: `(...args) => void` Adding `loop` to your interceptor will trigger for each loop of a looping hook.\n\n**register**: `(tap: Tap) => Tap | undefined` Adding `register` to your interceptor will trigger for each added `Tap` and allows to modify it.\n\n## Context\n\nPlugins and interceptors can opt-in to access an optional `context` object, which can be used to pass arbitrary values to subsequent plugins and interceptors.\n\n``` js\nmyCar.hooks.accelerate.intercept({\n\tcontext: true,\n\ttap: (context, tapInfo) => {\n\t\t// tapInfo = { type: \"sync\", name: \"NoisePlugin\", fn: ... }\n\t\tconsole.log(`${tapInfo.name} is doing it's job`);\n\n\t\t// `context` starts as an empty object if at least one plugin uses `context: true`.\n\t\t// If no plugins use `context: true`, then `context` is undefined.\n\t\tif (context) {\n\t\t\t// Arbitrary properties can be added to `context`, which plugins can then access.\n\t\t\tcontext.hasMuffler = true;\n\t\t}\n\t}\n});\n\nmyCar.hooks.accelerate.tap({\n\tname: \"NoisePlugin\",\n\tcontext: true\n}, (context, newSpeed) => {\n\tif (context && context.hasMuffler) {\n\t\tconsole.log(\"Silence...\");\n\t} else {\n\t\tconsole.log(\"Vroom!\");\n\t}\n});\n```\n\n## HookMap\n\nA HookMap is a helper class for a Map with Hooks\n\n``` js\nconst keyedHook = new HookMap(key => new SyncHook([\"arg\"]))\n```\n\n``` js\nkeyedHook.for(\"some-key\").tap(\"MyPlugin\", (arg) => { /* ... */ });\nkeyedHook.for(\"some-key\").tapAsync(\"MyPlugin\", (arg, callback) => { /* ... */ });\nkeyedHook.for(\"some-key\").tapPromise(\"MyPlugin\", (arg) => { /* ... */ });\n```\n\n``` js\nconst hook = keyedHook.get(\"some-key\");\nif(hook !== undefined) {\n\thook.callAsync(\"arg\", err => { /* ... */ });\n}\n```\n\n## Hook/HookMap interface\n\nPublic:\n\n``` ts\ninterface Hook {\n\ttap: (name: string | Tap, fn: (context?, ...args) => Result) => void,\n\ttapAsync: (name: string | Tap, fn: (context?, ...args, callback: (err, result: Result) => void) => void) => void,\n\ttapPromise: (name: string | Tap, fn: (context?, ...args) => Promise<Result>) => void,\n\tintercept: (interceptor: HookInterceptor) => void\n}\n\ninterface HookInterceptor {\n\tcall: (context?, ...args) => void,\n\tloop: (context?, ...args) => void,\n\ttap: (context?, tap: Tap) => void,\n\tregister: (tap: Tap) => Tap,\n\tcontext: boolean\n}\n\ninterface HookMap {\n\tfor: (key: any) => Hook,\n\tintercept: (interceptor: HookMapInterceptor) => void\n}\n\ninterface HookMapInterceptor {\n\tfactory: (key: any, hook: Hook) => Hook\n}\n\ninterface Tap {\n\tname: string,\n\ttype: string\n\tfn: Function,\n\tstage: number,\n\tcontext: boolean,\n\tbefore?: string | Array\n}\n```\n\nProtected (only for the class containing the hook):\n\n``` ts\ninterface Hook {\n\tisUsed: () => boolean,\n\tcall: (...args) => Result,\n\tpromise: (...args) => Promise<Result>,\n\tcallAsync: (...args, callback: (err, result: Result) => void) => void,\n}\n\ninterface HookMap {\n\tget: (key: any) => Hook | undefined,\n\tfor: (key: any) => Hook\n}\n```\n\n## MultiHook\n\nA helper Hook-like class to redirect taps to multiple other hooks:\n\n``` js\nconst { MultiHook } = require(\"tapable\");\n\nthis.hooks.allHooks = new MultiHook([this.hooks.hookA, this.hooks.hookB]);\n```\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/webpack/tapable.git"
  },
  "scripts": {
    "pretty": "prettier --loglevel warn --write lib/*.js lib/__tests__/*.js",
    "pretty-lint": "prettier --check lib/*.js lib/__tests__/*.js",
    "test": "jest",
    "travis": "yarn pretty-lint && jest --coverage && codecov"
  },
  "types": "./tapable.d.ts",
  "version": "2.2.0"
}
